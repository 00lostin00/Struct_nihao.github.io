[{"content":"字符串 字符数组 字符数组就是以字符类型定义的数组。 字符数组定义方式：\n1 2 3 4 char ch[123];//定义了一个字符的数组 int n;//表示定义字符数组的长度 cin \u0026gt;\u0026gt; ch;//可以直接读入一个字符串，下标从0~n-1 n = strlen(ch);//计算字符数组的长度 它具有普通数组的特性和少部分字符串数组的特性。\n字符串 字符串实际上是使用 null 字符 \\0终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。\n字符数组定义方式：\n1 2 3 4 5 6 string s;//定义一个字符串 cin \u0026gt;\u0026gt; s;//读出一个没有空格的字符串 getling (cin,s);//读入整行字符串，可以包含空格 n = s.size();//计算字符串长度 n = strlen(s);//另一种计算字符串长度的题 s2 = s.substr(i,j)//表示从i位置往后切到i+j-1个字符 stoi() 用于把字符串转化为整数 to_string() 用于把数字转化为字符串\n字符串的遍历 1 2 3 4 5 6 7 string s; cin\u0026gt;\u0026gt;s; int n = s.size(); for(int i=0;i\u0026lt;n;i++) { cout\u0026lt;\u0026lt;s[i]\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;;//表示输出 } ASCII码表 $ASCII码表$ 就是将某些字符和数字进行转化的比如 ：\n1 2 char p = (char) 65;//此时的p是A int q = (int) \u0026#39;a\u0026#39;;//此时的q是97 示例题目：读入两个数，将两个数字倒着相连，并输出这个数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; string s; while (b) { int x = b % 10; s += x + \u0026#39;0\u0026#39;; b /= 10; } while (a) { int x = a % 10; s += x + \u0026#39;0\u0026#39;; a /= 10; } cout \u0026lt;\u0026lt; s; return 0; } 结构体 定义/访问/修改元素 首先可以先定义个结构体，定义完结构体具有类似 int char double 的性质，可以像这些已有的结构类型定义变量。 然后结构体里面可以存好多类型的成员元素。可以使用 变量名.成员元素名 进行访问，也可以使用 指针名-\u0026gt;成员元素名 或者 使用 (*指针名).成员元素名 进行访问。例如使用 (*ptr).v = tmp 或者 ptr-\u0026gt;v = tmp 可以将结构体指针 ptr 指向的结构体的成员元素 v 赋值为 tmp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 struct student {//定义个学生的结构体 string name;//学生姓名 int score;//学生分数 string boyfriend;//他女朋友名字 string girlfriend;//她男朋友名字 } ;//加分号 student zts;//表示开了一个zts的student变量 student Class[100];//表示开了一个Class的数组变量 struct D_student {//定义个小学生的结构体 string name;//大学生姓名 int score;//大学生分数 string boyfriend;//大学生女朋友名字 string girlfriend;//大学生男朋友名字 } ;//加分号 int main () { cin\u0026gt;\u0026gt;zts.name\u0026gt;\u0026gt;zts.score\u0026gt;\u0026gt;zts.boyfriend;//zts的名字，zts的分数，zts的男朋友 cout\u0026lt;\u0026lt;zts.name\u0026lt;\u0026lt;zts.score\u0026lt;\u0026lt;zts.boyfriend;//输出zts的名字，zts的分数，zts的男朋友 for(int i=0;i\u0026lt;100;i++) { cin\u0026gt;\u0026gt;Class[i].name;//表示读入每一个人的姓名 cin\u0026gt;\u0026gt;Class[i].score;//表示读入每一个人的分数 cin\u0026gt;\u0026gt;Class[i].boyfriend;//表示读入每一个人的男朋友 cin\u0026gt;\u0026gt;Class[i].girlfriend;//表示读入每一个人的女朋友 } //之后可以对结构体进行一些操作。。。 return 0; } 首先，条条大路通罗马，可以不使用结构体达到相同的效果。但是结构体能够显式地将成员元素（在算法竞赛中通常是变量）捆绑在一起，如本例中的 student 结构体，便将 boyfriend,girlfriend 放在了一起（定义这个结构体的实际意义是表示一个学生的男朋友和女朋友）。这样的好处边是限制了成员元素的使用。\n想象一下，如果不使用结构体而且有两个数组 boyfriend[], girlfriend[]，很容易写混淆。\n但如果使用结构体，能够减轻出现使用变量错误的几率。\n并且不同的结构体（结构体类型，如 student 这个结构体）或者不同的结构体变量（结构体的实例，如上方的 D_student 数组）可以拥有相同名字的成员元素（如 student.name,D_student.name），同名的成员元素相互独立（拥有独自的内存，比如说修改 student.name 不会影响 D_student.name 的值）。\n这样的好处是可以使用尽可能相同或者相近的变量去描述一个物品。比如说 Object 里有 value 这个成员变量；我们还可以定义一个 Car 结构体，同时也拥有 value 这个成员；如果不使用结构体，或许我们就需要定义 valueOfObject[],valueOfCar[] 等不同名称的数组来区分。\n例题讲解： 函数 如何组织程序？ C的设计思想是，把函数用作构建块。\n函数（function）是完成特定任务的独立程序单元\n为什么要学习函数？ 使用函数可以省去编写重复代码的差事。\n提高代码可读性。\n创建并使用函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void PrintText(string text); // 函数原型 int main() { PrintText(); // 函数调用 return 0; } void PrintText(string text) // 函数定义 { cout \u0026lt;\u0026lt; text \u0026lt;\u0026lt; endl; } 函数原型 1 void PrintText(string text); 告诉编译器函数 PrintText 的类型，一般来说\n其中 void 为函数类型，表明函数没有返回值。\n括号中的代码 string text 表明该函数的要输入一个 string类 的变量text。\n函数调用 1 PrintText(); 表明在此处实行函数\n当计算机执行到该行时，会找到这个函数的定义并执行其中内容，实行完后回到主调函数（例子中为main（））继续进行下一行。\n函数定义 1 2 3 4 void PrintText(string text) { cout \u0026lt;\u0026lt; text \u0026lt;\u0026lt; endl; } 定义函数要干什么\n其中\n1 void PrintText() 为函数头。\n其余为函数体。\n需要注意，定义函数时的函数头后面没有分号，以表明此处在定义函数而不是调用或者声明函数。\n","date":"2024-11-16T22:26:51+08:00","permalink":"http://localhost:1313/p/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%93%E6%9E%84%E4%BD%93%E5%87%BD%E6%95%B0/","title":"字符串结构体函数"},{"content":"循环 有时，我们需要做一件事很多遍，为了不写过多重复的代码，我们需要循环。\n有时，循环的次数不是一个常量，那么我们无法将代码重复多遍，必须使用循环。\n基本循环语句 1. for语句 1 2 3 4 for (int i = 1; i \u0026lt;= n; i++)//初始化; 判断条件; 更新 { //做一些你想做的事情 } 简而言之就是，对 $i$ 这个变量进行循环，从 $1$ 循环到 $n$ 次，每次加 $1$ 。 $for$ 语句的三个部分中，任何一个部分都可以省略。其中，若省略了判断条件，相当于判断条件永远为真。\n代码示例：输出 3-100内的偶数 1 2 3 4 5 for (int i = 3; i \u0026lt;= 100; i++) { if (i%2 == 0) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } 2.while语句 1 2 3 4 5 int n = 100; while(a\u0026gt;b)//判断条件 { //做些事情 } 可以简单理解为循环版的 $if$ 语句。$if$ 语句是判断一次，如果条件成立，则执行后面的语句；$while$ 是每次判断，如果条件成立，则执行循环体中的语句，否则停止。\n代码示例：求斐波那契数列的第n项。f(1) = 1, f(2) = 1, f(3) = 2, f(n) = f(n-1) + f(n-2) 1 2 3 4 5 6 7 8 9 10 11 12 13 int n; cin \u0026gt;\u0026gt; n; int a = 1, b = 1, i = 1; while (i \u0026lt; n) { int c = a + b; a = b; b = c; i ++ ; } cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; 3. do while 语句 do while 语句很不常用，大家感兴趣可以自己了解。\n跳转语句 break;// 表示跳出当前最近的一层循环 continue;//直接跳到当前循环体的结尾\n示例代码，求1-n 中前 50 个偶数的和 1 2 3 4 5 6 7 8 9 10 11 12 13 int n; int sum = 0,res = 0; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { if (res == 50 ) break; if (i % 2 == 0) { sum += i; res++; } } 示例代码：给出for和while两种做法： 题目：给出 $n$ 和 $n$ 个整数 $a_i$，求这 $n$ 个整数中最小值是什么。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int n, min_w = INT_MAX; // INT_MAX表示int范围内的最大值 cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; //for 形式 for (int i = 1; i \u0026lt;= n; i++) { if (min_w \u0026gt; a[i]) min_w = a[i]; } //while 形式 int i = 1; while (i \u0026lt;= n) { if (min_w \u0026gt; a[i]) min_w = a[i]; i++; } cout \u0026lt;\u0026lt; min_w; 当然，还有嵌套循环，for+for，for+while，while+while等 示例代码：输出一个 n 阶实心菱形 此为一个 7 阶实心菱形\n1 2 3 4 5 6 7 * *** ***** ******* ***** *** * 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, a = 1, b = 0; int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { for (int k = 1; k \u0026lt; n / 2 + 1 - b; k++) cout \u0026lt;\u0026lt; \u0026#34; \u0026#34;; for (int j = n / 2 + 1 - b; j \u0026lt;= n / 2 + 1 + b; j++) cout \u0026lt;\u0026lt; \u0026#34;*\u0026#34;; if (i == n / 2 + 1) a = -1; b += a; cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return 0; } 数组 数组是存放相同类型对象的容器，数组中存放的对象没有名字，而是要通过其所在的位置访问。数组的大小是固定的，不能随意改变数组的长度。\n定义数组 数组的声明形如 a[d]，其中，a 是数组的名字，d 是数组中元素的个数。在编译时，d 应该是已知的，也就是说，d 应该是一个整型的常量表达式。\n1 2 3 4 5 int d1 = 42; const int d2 = 42; int arr1[d1]; // 错误：d1 不是常量表达式 int arr2[d2]; // 正确：arr2 是一个长度为 42 的数组 int arr3[42]; // 正确：arr3 是一个长度为 42 的数组 不能将一个数组直接赋值给另一个数组：\n1 2 3 int arr1[3]; int arr2 = arr1; // 错误 arr2 = arr1; // 错误 应该尽量将较大的数组定义为全局变量。因为局部变量会被创建在栈区中，过大（大于栈的大小）的数组会爆栈，进而导致 RE。如果将数组声明在全局作用域中，就会在静态区中创建数组。\n数组的初始化 在main函数内部，未初始化的数组中的元素是随机的。 定义在全局变量的数组，int 类型初始值就是全部赋值为 0。\n访问数组元素 可以通过下标运算符 [] 来访问数组内元素，数组的索引（即方括号中的值）从 0 开始。以一个包含 10 个元素的数组为例，它的索引为 0 到 9，而非 1 到 10。但在竞赛中，为了使用方便，我们通常会将数组开大一点，不使用数组的第一个元素，从下标 1 开始访问数组元素。\n示例代码：从标准输入中读取一个整数n，再读取n个数，存入数组中。 1 2 3 4 5 6 7 8 #include \u0026lt;iostream\u0026gt; using namespace std; int arr[1001]; // 数组 arr 的下标范围是 [0, 1001) int main() { int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; arr[i]; } 多维数组 多维数组就是数组的数组。 多维数组的实质是「数组的数组」，即外层数组的元素是数组。一个二维数组需要两个维度来定义：数组的长度和数组内元素的长度。\n1 2 3 4 5 int a[3][4]; // 大小为3的数组，每个元素是含有4个整数的数组。 int arr[10][20][30] = {0}; // 将所有元素初始化为0 // 大小为10的数组，它的每个元素是含有20个数组的数组 // 这些数组的元素是含有30个整数的数组 我们经常使用嵌套的 for 循环来处理二维数组。\n例：从标准输入中读取两个数n和m,.分别表示黑白图片的高与宽，满足$n,m \\leq 1000$。对于接下来的n行数据，每行有用空格分隔开的m个数，代表这一位置的亮度值。现在我们读取这张图片，并将其存入二维数组中。\n1 2 3 4 5 6 const int MAXN = 1001; int pic[MAXN][MAXN]; int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; ++i) for (int j = 1; j \u0026lt;= m; ++j) cin \u0026gt;\u0026gt; pic[i][j]; 同样地，你可以定义三维、四维，以及更高维的数组。\n","date":"2024-11-06T21:14:10+08:00","permalink":"http://localhost:1313/p/%E5%BE%AA%E7%8E%AF%E5%92%8C%E6%95%B0%E7%BB%84/","title":"循环和数组"},{"content":"可能有的题解不够完善，后续会把题目都放到网站上，题解也会详细写好的 A 回文 回文题解 B 立希喂猫 二分+前缀和，思路来不及阐释了，看代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long const int N = 101001; int s[N], ss[N]; long long f[N]; int n, m, q; struct nihao { int a, b; } p[N]; bool cmp(nihao x, nihao y) { return x.b \u0026lt; y.b; } signed main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; p[i].a; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; p[i].b; sort(p + 1, p + n + 1, cmp); for (int i = 1; i \u0026lt;= n; i++) { s[i] = s[i - 1] + p[i].a * p[i].b; ss[i] = ss[i - 1] + p[i].a; } cin \u0026gt;\u0026gt; q; while (q--) { int k; int res = 0, ans = 0; cin \u0026gt;\u0026gt; k; int l = 1, r = n; while (l \u0026lt;= r) { int mid = (l + r) / 2; if (p[mid].b \u0026gt;= k) r = mid - 1; else l = mid + 1, ans = mid; } // cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; if (p[ans + 1].b \u0026lt; k) res += s[n] - s[0]; else { res += s[ans] - s[0]; res += (ss[n] - ss[ans]) * k; } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return 0; } C words 找到连续的含大于等于 $3$ 个 $*$ 的个数，加起来\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 101001; int n, m, ans; int main() { cin \u0026gt;\u0026gt; m; getchar(); for (int i = 1; i \u0026lt;= m; i++) { string s; getline(cin, s); // cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; n = s.size(); // cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; int res = 0; for (int i = 0; i \u0026lt; n; i++) { if (s[i] == \u0026#39;*\u0026#39;) { int sum = 1; for (int j = i + 1; j \u0026lt; n; j++) { if (s[j] == \u0026#39;*\u0026#39;) sum++; else { i = j; break; } if (j == n - 1) { i = j; break; } } // cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; if (sum \u0026gt;= 3) res++; } } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return 0; } D 奖学金 这里给出主席树的做法，也可以用优先队列\n奖学金题解 E 不空白的画布 不空白的画布题解 F 细胞分裂 质因数分解一下，由于 $m1$ 范围为 $3000$ ，范围够用，对于每一种细胞找到某个质因子需要分裂的最大次数，把所有细胞得到的值取最小。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 101001; const int _max = INT_MAX - 1; int n, m, ans = INT_MAX - 1, m1, m2; int a[N]; struct nihao { int a, b; }; vector\u0026lt;nihao\u0026gt; qm; void divide(int x, vector\u0026lt;nihao\u0026gt; \u0026amp;q) { for (int i = 2; i \u0026lt;= x / i; i++) { if (i \u0026gt; 30000) { return; } if (x % i == 0) { int res = 0; while (x % i == 0) { res++; x /= i; } q.push_back({i, res}); } } if (x \u0026gt; 1) q.push_back({x, 1}); } int cloe(int a, int b) { if (a % b != 0) return a / b + 1; return a / b; } int check(vector\u0026lt;nihao\u0026gt; x, vector\u0026lt;nihao\u0026gt; y) { int j = 0; int sum = 0; for (auto i : y) { bool flag = 0; for (auto j : x) { if (j.a == i.a) { flag = 1; sum = max(sum, cloe(i.b, j.b)); break; } } if (flag == 0) return -1; } return sum; } signed main() { cin \u0026gt;\u0026gt; n; cin \u0026gt;\u0026gt; m1 \u0026gt;\u0026gt; m2; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; divide(m1, qm); for (int i = 0; i \u0026lt; qm.size(); i++) qm[i].b *= m2; for (int i = 1; i \u0026lt;= n; i++) { vector\u0026lt;nihao\u0026gt; q; divide(a[i], q); int sum = 0; sum = check(q, qm); if (sum != -1) ans = min(sum, ans); } if (ans != _max) cout \u0026lt;\u0026lt; ans; else cout \u0026lt;\u0026lt; -1; return 0; } G 廊桥分配 廊桥分配题解 H 消除序列 消除序列题解 I 小木棍 暴搜，考虑多种剪枝优化，代码里面有，详细的剪枝过会儿再写。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define gc getchar() #define re read() #define N 61 const int modd = 19650827; int read() { int a = 0; bool f = 0; char x = gc; while (!isdigit(x)) { f |= x == \u0026#39;-\u0026#39;; x = gc; } while (isdigit(x)) { a = (a \u0026lt;\u0026lt; 3) + (a \u0026lt;\u0026lt; 1) + (x - \u0026#39;0\u0026#39;); x = gc; } return f ? -a : a; } const int inf = INT_MAX; int n; int ton[N]; int maxx = -inf, minn = inf, tot; void dfs(int beg, int end, int k, int q) { // cout\u0026lt;\u0026lt;beg\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;end\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;k\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;q\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; if (k == 0) { cout \u0026lt;\u0026lt; end; exit(0); } if (beg == end) { dfs(0, end, k - 1, maxx); } for (int i = q; i \u0026gt;= 1; i--) { if (ton[i] \u0026amp;\u0026amp; beg + i \u0026lt;= end) { ton[i]--; dfs(beg + i, end, k, i); ton[i]++; if (beg == 0 || beg + i == end) { // cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; break; } } } return; } int main() { n = re; while (n--) { int x; x = re; if (x \u0026lt;= 50) { ton[x]++; tot += x; maxx = max(x, maxx); minn = min(x, minn); } } int k = tot / 2; for (int i = maxx; i \u0026lt;= k; i++) { if (tot % i == 0) { //\tcout\u0026lt;\u0026lt;\u0026#34;dasbidasi\\n\\n\u0026#34;; dfs(0, i, tot / i, maxx); } } cout \u0026lt;\u0026lt; tot; return 0; } J 小红的好子串询问 使用线段树来解决区间问题 详细思路会更新\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; // #pragma gcc optimize(2) // #pragma gcc optimize(3) const int N = 1e6 + 50, MOD = 1e9 + 7, base = 13331; int n, m, a[N], f[7][N]; int p[7][3] = {{0, 0, 0}, {1, 2, 3}, {1, 3, 2}, {2, 1, 3}, {2, 3, 1}, {3, 1, 2}, {3, 2, 1}}; unordered_map\u0026lt;char, int\u0026gt; mymap; void build(int idx, int k, int l, int r) { if (l == r) { f[idx][k] = (p[idx][l % 3] != a[l] ? 1 : 0); return; } int mid = (l + r) / 2; build(idx, k + k, l, mid); build(idx, k + k + 1, mid + 1, r); f[idx][k] = f[idx][k + k] + f[idx][k + k + 1]; } void revise(int idx, int k, int l, int r, int x) { if (l == r) { f[idx][k] = (p[idx][l % 3] != a[l] ? 1 : 0); return; } int mid = (l + r) / 2; if (x \u0026lt;= mid) revise(idx, k + k, l, mid, x); else revise(idx, k + k + 1, mid + 1, r, x); f[idx][k] = f[idx][k + k] + f[idx][k + k + 1]; } int query(int idx, int k, int l, int r, int x, int y) { if (l == x \u0026amp;\u0026amp; r == y) { return f[idx][k]; } int mid = (l + r) / 2; if (y \u0026lt;= mid) return query(idx, k + k, l, mid, x, y); else if (x \u0026gt; mid) return query(idx, k + k + 1, mid + 1, r, x, y); else return query(idx, k + k, l, mid, x, mid) + query(idx, k + k + 1, mid + 1, r, mid + 1, y); } void solve() { string s; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s; mymap[\u0026#39;r\u0026#39;] = 1; mymap[\u0026#39;e\u0026#39;] = 2; mymap[\u0026#39;d\u0026#39;] = 3; for (int i = 1; i \u0026lt;= n; i++) { a[i] = mymap[s[i - 1]]; } for (int i = 1; i \u0026lt;= 6; i++) { build(i, 1, 1, n); } while (m--) { int st; cin \u0026gt;\u0026gt; st; if (st == 1) { int x; char c; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; c; a[x] = mymap[c]; for (int i = 1; i \u0026lt;= 6; i++) revise(i, 1, 1, n, x); } else { int l, r, mn = 1e9; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; for (int i = 1; i \u0026lt;= 6; i++) { mn = min(mn, query(i, 1, 1, n, l, r)); } cout \u0026lt;\u0026lt; mn \u0026lt;\u0026lt; endl; } } } signed main() { ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int t = 1; // cin \u0026gt;\u0026gt; t; while (t--) { solve(); } return 0; } ","date":"2024-10-09T22:29:45+08:00","permalink":"http://localhost:1313/p/acm%E6%A8%A1%E6%8B%9F%E8%B5%9B%E9%A2%98%E8%A7%A3/","title":"Acm模拟赛题解"},{"content":"主席树 首先这是一个不该用主席树写的题，正解应该是用优先队列来写比主席树快的多。\n但是， 既然学了主席树就要有用主席树的使命，不会用指针只能用数组写。\n不过这个如果用主席树的思路也是很好想的，不用搞这搞那的，只需要建立主席树，建立主席树，一直建，然后就没了，干练精快。\n分析： 题中给出了 $c$ 学生总数， $n$ 领奖的学生个数， $f$ 奖金总额最大数。\n我们要挑出 $n$ 个学生去领奖学金，我最开始是想着建立 $c$ 个主席树，然后找到前 $n$ 小，但是没必要这样。\n对于答案的限制条件是要求中位数最大，本来感觉还要算一下，但是数据说是奇数，那么中位数就是确定的值了，我们就可以从中位数开始查起。\n所以，我们先把 $1$ 到 $c$ 的数据存到主席树里面，就是查询的时候需要对原来的模板改一下，我们需要开一个 $Sum$ 来存奖学金。\n查询的时候把前 $k$ 小和 后 $k$小的值用 $ans1$ 和 $ans2$ 和此时的中位数的和与 $f$ 作比较，直到找到最大的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int query(int use,int now,int l,int r,int k) { ll ans=0; int mid=(l+r)\u0026gt;\u0026gt;1; int h=t[t[now].l].sum-t[t[use].l].sum;//h是权值线段树操作 if(l==r){ return k*b[l];//奖学金有一样的，只要这个节点的k个人！！！ } if(k\u0026lt;=h)ans+=query(t[use].l,t[now].l,l,mid,k);//递归的都是节点 else { ans+=t[t[now].l].Sum-t[t[use].l].Sum;//加上查过的数 ans+=query(t[use].r,t[now].r,mid+1,r,k-h);//注意要减去左区间的数 } return ans; } 注意\n1 if(l==r) return k*b[l]; 一定要用 $k$ 乘一遍，因为可能存在一个结点包含几个相同的数据的情况。\n我们在主函数中查询的时候让成绩从大到小排序，我们令 $anss$ 为$-1$ 这样我们只用找到第一个 $anss$ 不是 $-1$ 情况就可以退出循环了。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 #include\u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define re read() #define mm 400009 #define w qwrite #define gc getchar()\tusing namespace std; //定义区 struct node{ int a,b; bool operator \u0026lt;( const node \u0026amp; x)const { return x.a\u0026lt;a;//从大到小 } }len[mm]; struct nihao { int fre,l,r,sum;//历史的树根节点，左子树，右子树(都是指的节点)//某个区间有几个数 int Sum;//原数组的值 }t[mm\u0026lt;\u0026lt;4]; int b[mm];//原数组，离散数组 int nodee;//节点 int inst;//修改插入的点 int g;//离散的右边界 int tok[mm]; int n,m,c,kk; int f,anss=-1; ll ans1,ans2; //函数区 int read(){//int ull int x=0,y=1; char s=gc;if(s==\u0026#39;-\u0026#39;)y=-1; while(!isdigit(s))s=gc; while(isdigit(s))x=(x\u0026lt;\u0026lt;1)+(x\u0026lt;\u0026lt;3)+s-\u0026#39;0\u0026#39;,s=gc; return x*y; } void qwrite(int x) { if(x==0){putchar(\u0026#39;0\u0026#39;);puts(\u0026#34;\u0026#34;);return ;} int cnt=0,u[400]; if(x\u0026lt;0) x=-x,putchar(\u0026#39;-\u0026#39;); while(x){u[cnt++]=x%10;x/=10;} while(cnt--) putchar(u[cnt]+\u0026#39;0\u0026#39;);puts(\u0026#34;\u0026#34;); } void make(int \u0026amp;x,int l,int r)//建树 { x=++nodee; if(l==r)return ;//叶节点 int mid=(l+r)\u0026gt;\u0026gt;1; make(t[x].l,l,mid); make(t[x].r,mid+1,r); return ; } int modify(int x,int l,int r) { int xi=++nodee;//建立新节点 t[xi].l=t[x].l;t[xi].r=t[x].r;t[xi].sum=t[x].sum+1;t[xi].Sum+=t[x].Sum+b[inst];//传递树节点数据 if(l==r)return xi;//已经到叶节点，不用再建树了 int mid=(l+r)\u0026gt;\u0026gt;1; if(inst\u0026lt;=mid) t[xi].l=modify(t[xi].l,l,mid);//对于这个数比这个区间小就到左边，右边同理 else t[xi].r=modify(t[xi].r,mid+1,r); return xi; } int query(int use,int now,int l,int r,int k) { ll ans=0; int mid=(l+r)\u0026gt;\u0026gt;1; int h=t[t[now].l].sum-t[t[use].l].sum;//h是权值线段树操作 if(l==r){ return k*b[l];//奖学金有一样的，只要这个节点的k个人！！！ } if(k\u0026lt;=h)ans+=query(t[use].l,t[now].l,l,mid,k);//递归的都是节点 else { ans+=t[t[now].l].Sum-t[t[use].l].Sum;//加上查过的数 ans+=query(t[use].r,t[now].r,mid+1,r,k-h);//注意要减去左区间的数 } return ans; } signed main () { int l,r; n=re,c=re,f=re;kk=n/2; for(int i=1;i\u0026lt;=c;i++)len[i].a=re,len[i].b=re,b[i]=len[i].b; sort(len+1,len+1+c); //重载过了 sort(b+1,b+c+1); g=unique(b+1,b+c+1)-b-1; make(t[0].fre,1,g); for(int i=1;i\u0026lt;=c;i++)//全部建树 { inst=lower_bound(b+1,b+g+1,len[i].b)-b;//找到a[i]对应的离散化下标 t[i].fre=modify(t[i-1].fre,1,g);//基于上一个版本的树 } for(int i=1+(n-1)/2;i\u0026lt;=c-(n/2);i++) { ans1=query(t[0].fre,t[i-1].fre,1,g,kk); ans2=query(t[i].fre,t[c].fre,1,g,kk); if(ans1+ans2+len[i].b\u0026lt;=f)anss=max(anss,len[i].a); if(anss!=-1)break; } w(anss); return 0; } ","date":"2024-10-09T22:29:00+08:00","permalink":"http://localhost:1313/p/%E5%A5%96%E5%AD%A6%E9%87%91/","title":"奖学金"},{"content":"分析 记忆碎片数量为画上的相同颜色连续块个数，要使记忆碎片的数量最多，即相同颜色的连续块数最少即可。我们有操作次数，使相同颜色的的连续块变成不同颜色的连续块，而保证绝对使颜色块不同且使改变后的颜色块不会与下一个颜色块再次连续起来即 $k\\geq3$。\n做法 首先遍历一下整个数组，统计出所有相同颜色的连续块。 考虑把他们分成三类：连续奇数块，连续偶数块，单个的一块。\n这三类无论是否操作都有各自的一块，即先把所有的相同颜色的连续块统计起来。 单个的块无需操作，自成一块。\n之后考虑奇数块，把任意奇数块在他们间隔的中间改变颜色每次产生的贡献为 $2$，例如 $ 2 $ $ 2 $ $2 $，只需要把中间的块改变即可 $ 2 $ $ 1 $ $2 $，除去原来自己本来的一块，改变之后多了两块。\n再之后考虑偶数块，其实考虑起来和奇数块一样，只需要把偶数（$n\\gt2$）的头块单独拎出来存起来先不考虑，之后偶数块变成奇数块和奇数块考虑的一样，贡献一样 $2$。\n最后考虑被单独拎出来的偶数头块（$n$，取剩余的操作次数 $m$ 和 $n$ 的最小值即为剩余最多被改变的次数，贡献为 $1$。\n不过由于单拎出来的偶数头快贡献为 $1$，所以它需要最后考虑。\n最后，把所有的贡献都加起来即可。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int a[10000000],f[1000000]; int main () { int t;cin\u0026gt;\u0026gt;t; while(t--) { int n,m,k;cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k; int sum=0,tt=1,ty=0; a[0]=-110; for(int i=1;i\u0026lt;=n;i++) { cin\u0026gt;\u0026gt;a[i];a[0]=a[i]; if(a[i]==a[i-1])f[tt]++; else {f[++tt]=1;} } for(int i=1;i\u0026lt;=tt;i++) { sum++; if(f[i]==1||f[i]%2==0)continue; int p=f[i]/2;if(p\u0026gt;=m)p=m,m=0;else m-=p; sum+=2*p; } for(int i=1;i\u0026lt;=tt;i++) { if(f[i]%2!=0)continue; ++ty; int p=(f[i]-1)/2;if(p\u0026gt;=m)p=m,m=0;else m-=p; sum+=2*p; } sum+=min(m,ty);if(sum\u0026gt;n)sum=n; cout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; for(int i=1;i\u0026lt;=tt;i++)f[i]=0; } return 0; } ","date":"2024-10-09T22:28:36+08:00","permalink":"http://localhost:1313/p/%E4%B8%8D%E7%A9%BA%E7%99%BD%E7%9A%84%E7%94%BB%E5%B8%83/","title":"不空白的画布"},{"content":"分析 首先，我们先来理解一下题意，\n对于一个 $2n$ 的数列，\n存在删去末尾（左右），依次存放 $b[1],b[2],b[3]~b[2n]$ 的数。\n那么我们就要想一下该怎么删？\n对于这样一个数列，\n我们一直删去的是末尾的数，\n即它被删的趋势应该是从两边到与 $a[1] $ 对应的数 $a[t]$ 为核心而向核心靠拢的，\n最后删去的是核心 $a[t]$ 。\n那么我们要删的数 $a[i]$ 的对应的数 $a[j]$，\n必须在 $a[t]$ 为核心向两边不断延伸的两边的数，分别为 $top,end$ 。\n比如，\n1 7 4 5 2 1 7 2 5 4 ，\n对于我们删去的数 $a[1]=1，a[t]=1,t=6$ ，\n删去之后\n7 4 5 2 1 7 2 5 4\n那么我们要删去的下一个数分别为 $7$ 或 $4$ ，\n而在 $a[t]=1$ 的旁边只有 $2$ 和 $ 7$，\n倘若删去 $4$，$a[t]$ 旁边没有 $4$，则情况不成立。\n而 $a[t]$ 旁边有 $7$，那么可以删去 $7$，\n数列变为，\n4 5 2 1 7 2 5 4。\n此时对于每删一个数我们同时又将其对应位置找到了，\n这样只需要判断 $n$ 次，就可以判断是否回文。\n而为什么要这样做呢？\n因为我们第 $i$ 次删数时，\n那么它对应的应该是倒数第 $i$ 次被删的。\n即数列 $b$，\n由 $11-\u0026gt;1771$,\n此时应该明显看出 $4$ 不可以了吧。\n若情况都不存在，那么则不成立。\n边界条件 其实我们可以开4个下标变量 $h,e,top,end$ 。\nh指数列a的左末尾，e指数组a的右末尾，\ntop指与上文分析的核心数的左边，end则为右边。\n还是上一个数列，\n1 7 4 5 2 1 7 2 5 4，\n删去 $1$ 后，$h=7,e=4,top=2,end=7$。\n即若存在 $a[h]==(a[top]||a[end])||a[e]==(a[top]||a[end])$。\n那么此时可以构成回文，\n但是对于题目要求的字典序最大，那么我们应该优先删去左边的，\n即 $a[h]==(a[top]||a[end])$。\n那么我们需要满足的边界条件，\n对于区间 $[top,end]$ 为 $[h,e]$ 的真子集符号我不会打\n很显然为 $top\u0026gt;h,e\u0026gt;end$，\n但同时还存在 $end\u0026gt;h,e\u0026gt;top$（建议好好想一下）。\n而为什么会有这样的边界，\n想一下，\n当你左边的 $h$ 正好和 $end $ 相等的时候，\n右边的 $e$ 正好和 $top$ 相等的时候。\n情况成立。\n1 2 3 4 if(a[h]==a[top]\u0026amp;\u0026amp;top\u0026gt;h){h++,i++,top--,b[i]=\u0026#39;L\u0026#39;,b[2*k-i+1]=\u0026#39;L\u0026#39;;continue;} if(a[h]==a[end]\u0026amp;\u0026amp;end\u0026gt;h){h++,i++,end++,b[i]=\u0026#39;L\u0026#39;,b[2*k-i+1]=\u0026#39;R\u0026#39;;continue;} if(a[e]==a[top]\u0026amp;\u0026amp;e\u0026gt;top){e--,i++,top--,b[i]=\u0026#39;R\u0026#39;,b[2*k-i+1]=\u0026#39;L\u0026#39;;continue;} if(a[e]==a[end]\u0026amp;\u0026amp;end\u0026lt;e){e--,i++,end++,b[i]=\u0026#39;R\u0026#39;,b[2*k-i+1]=\u0026#39;R\u0026#39;;continue;} 最后再说一下，\n对于我们的初始删除的数 $a[i]$ 不一定为左边的 $ a[1]$ ，\n也有可能是从右边 $a[2*n]$。\n但对于字典序最大，\n我们应该优先删除左边，\n左边如果不行再删去右边。\n因为初始删去的值是可以任意选择的。\n所以，这篇题解也算写完了。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstring\u0026gt; #define r read() //#define int __int128 #define gc getchar() int a[1000005],t,k; char b[1000005]; int read(){//int ull int x=0; char s=gc; while(!isdigit(s))s=gc; while(isdigit(s))x=(x\u0026lt;\u0026lt;1)+(x\u0026lt;\u0026lt;3)+s-\u0026#39;0\u0026#39;,s=gc; return x; } using namespace std; void Q() { int top,end; for(int i=2;i\u0026lt;=2*k;i++)if(a[i]==a[1]){top=i-1;break;} end=top+2; b[1]=\u0026#39;L\u0026#39;,b[2*k]=\u0026#39;L\u0026#39;; int i=1,h=2,e=2*k; while(i\u0026lt;k) { if(a[h]==a[top]\u0026amp;\u0026amp;top\u0026gt;h){h++,i++,top--,b[i]=\u0026#39;L\u0026#39;,b[2*k-i+1]=\u0026#39;L\u0026#39;;continue;} if(a[h]==a[end]\u0026amp;\u0026amp;end\u0026gt;h){h++,i++,end++,b[i]=\u0026#39;L\u0026#39;,b[2*k-i+1]=\u0026#39;R\u0026#39;;continue;} if(a[e]==a[top]\u0026amp;\u0026amp;e\u0026gt;top){e--,i++,top--,b[i]=\u0026#39;R\u0026#39;,b[2*k-i+1]=\u0026#39;L\u0026#39;;continue;} if(a[e]==a[end]\u0026amp;\u0026amp;end\u0026lt;e){e--,i++,end++,b[i]=\u0026#39;R\u0026#39;,b[2*k-i+1]=\u0026#39;R\u0026#39;;continue;} break; } if(i==k) for(int i=1;i\u0026lt;=2*k;i++)cout\u0026lt;\u0026lt;b[i]; if(i==k)return ; for(int i=2*k-1;i\u0026gt;=1;i--)if(a[i]==a[2*k]){top=i-1;break;}//a[i]==a[2*k-1] end=top+2; i=1,h=1,e=2*k-1; b[1]=\u0026#39;R\u0026#39;,b[2*k]=\u0026#39;L\u0026#39;; while(i\u0026lt;k) { if(a[h]==a[top]\u0026amp;\u0026amp;top\u0026gt;h){h++,i++,top--,b[i]=\u0026#39;L\u0026#39;,b[2*k-i+1]=\u0026#39;L\u0026#39;;continue;}//h+1 if(a[h]==a[end]\u0026amp;\u0026amp;end\u0026gt;h){h++,i++,end++,b[i]=\u0026#39;L\u0026#39;,b[2*k-i+1]=\u0026#39;R\u0026#39;;continue;}//h+1 if(a[e]==a[top]\u0026amp;\u0026amp;e\u0026gt;top){e--,i++,top--,b[i]=\u0026#39;R\u0026#39;,b[2*k-i+1]=\u0026#39;L\u0026#39;;continue;}//e if(a[e]==a[end]\u0026amp;\u0026amp;end\u0026lt;e){e--,i++,end++,b[i]=\u0026#39;R\u0026#39;,b[2*k-i+1]=\u0026#39;R\u0026#39;;continue;}//e cout\u0026lt;\u0026lt;\u0026#34;-1\u0026#34;;return ; } for(int i=1;i\u0026lt;=2*k;i++)cout\u0026lt;\u0026lt;b[i]; } signed /*int*/ main () { t=r; while(t--) { k=r; memset(a,0,sizeof(a)); for(int i=1;i\u0026lt;=2*k;i++) a[i]=r; Q(); cout\u0026lt;\u0026lt;endl; } return 0; } ","date":"2024-10-09T22:02:44+08:00","permalink":"http://localhost:1313/p/%E5%9B%9E%E6%96%87/","title":"回文"},{"content":"这个也是类似背包的问题，考虑\n定义状态：$dp_{i,j}$ 表示前 $i$ 场比赛凑成比赛的目标分数为 $j$ 是否存在。\n状态转移：$dp_{i,j}=dp_{i-1,j-a[i][k]}$ ，表示当在第 $i$ 场时选择第 $k$ 个题时构成的 $j$ 分数的转移。\n时间复杂度 $O(nmtarget)$\n该题算是 $0/1$ 背包的进阶吧\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 101001; int n, m, ans = 5050; bool dp[200][5050]; int a[200][30]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { cin \u0026gt;\u0026gt; a[i][j]; if (i == 1) dp[i][a[i][j]] = 1; } if (i \u0026gt; 1) { for (int j = 1; j \u0026lt;= 5050; j++) { for (int k = 1; k \u0026lt;= m; k++) { if (j - a[i][k] \u0026gt;= 1 \u0026amp;\u0026amp; dp[i - 1][j - a[i][k]]) dp[i][j] = 1; } } } } int target; cin \u0026gt;\u0026gt; target; for (int j = 5050; j \u0026gt;= 1; j--) { if (dp[n][j]) ans = min(ans, abs(j - target)); } cout \u0026lt;\u0026lt; ans; return 0; } ","date":"2024-10-02T19:32:47+08:00","permalink":"http://localhost:1313/p/p0008%E7%BB%84%E8%B5%9B%E9%A2%98/","title":"P0008组赛题"},{"content":"此题在我把时限开成 $2s$ 之后他有了两种做法，一个是 $O(1e9)$ 的背包做法，另一个是 $O(\\sqrt{x})$ 的组合数做法。虽然时限有些超，但确实是一个背包的好题。\n1. 背包做法 本题就是一个求方案数问题，本质就是一个背包问题。背包求方案数过会儿我会把题偷过来的\n考虑 $dp$ ，定义状态：前 $i$ 个数中第 $i$ 个位置数字是 $j$ 数的组合方案数。 状态转移： $$ dp_{i,j}=\\sum_{j=0}^x \\sum_{jt=0}^{j-1} (dp_{i-1,jt}+dp_{i,j}) $$ 但是这样会发现时间复杂度是 $O(nx^2)$ ，复杂度太高，考虑优化一下，题目说要保证每个前缀和的 $s_i$ 都是平方数，那么对应到 $dp$ 方程中就是每一个 $j$ 都是平方数，那么前 $x$ 数中最大有 $\\sqrt x$ 个平方数，那么 $j$ 的上限就是 $\\sqrt x$ ，而且对于每一个 $j$ 的取值都要满足是个平方数，那我们开个数组 $squares$ 表示存的都是 $j$ 的平方数即可，那么新的转移方程如下： $$ dp_{i,j}=\\sum_{j=1}^{\\sqrt x} \\sum_{jt=0}^{j-1} (dp_{i-1,jt}+dp_{i,j})\\quad({j,jt})\\in squares $$ 那么只需要把 $squares$ 数组预处理一下即可可以用vector。 新的方程时间复杂度 $O(nx)$\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;bits/stdc++.h\u0026gt; const int MOD = 1e9 + 7; using namespace std; int dp[1234][1234]; int squares[12360], t; int n, x, ans; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; x; dp[0][0] = 1; for (int i = 1; i * i \u0026lt;= x; ++i) { squares[++t] = i; dp[1][i] = 1; } for (int i = 1; i \u0026lt;= n; ++i) { for (int jt = 1; jt \u0026lt;= t; jt++) { int j = squares[jt]; for (int kt = 1; kt \u0026lt;= t \u0026amp;\u0026amp; squares[kt] \u0026lt; j; kt++) { dp[i][j] = (dp[i][j] + dp[i - 1][squares[kt]]) % MOD; } } } for (int jt = 1; jt \u0026lt;= t; jt++) { int j = squares[jt]; ans = (ans + dp[n][j]) % MOD; } cout \u0026lt;\u0026lt; ans; return 0; } 2. 组合数做法 其实该题的前缀和数列排列本质上就是可以构成的前缀和的那些数字的排列，从中选出 $n$ 个数，即 $C_{\\sqrt x} ^n$ 。下面给出 c++\u0026amp;python 的代码做法。C++中用到了快速幂的做法，马上会扩展到的\nC++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 101001; typedef long long LL; int n, m, ans; int fact[N], infact[N]; const int mod = 1e9 + 7; int qmi(int a, int b) { int res = 1 % mod; while (b) { if (b \u0026amp; 1) res = (LL)res * a % mod; a = (LL)a * a % mod; b /= 2; } return res; } int main() { fact[0] = infact[0] = 1; for (int i = 1; i \u0026lt; N; i++) { fact[i] = (LL)fact[i - 1] * i % mod; infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2) % mod; } int a, b; cin \u0026gt;\u0026gt; b \u0026gt;\u0026gt; a; a = sqrt(a); cout \u0026lt;\u0026lt; (LL)fact[a] * infact[b] % mod * infact[a - b] % mod \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } Python 1 2 3 4 5 6 7 8 9 10 11 # 导入需要的库 from math import comb import math mod = int(1e9) + 7 n,x=map(int,input().split()) # 计算组合数 k = int(math.sqrt(x)) answer = comb(k, n)%mod print(answer) #pragma GCC optimize(2) ","date":"2024-10-01T22:09:43+08:00","permalink":"http://localhost:1313/p/p0004%E5%89%8D%E7%BC%80%E5%B9%B3%E6%96%B9%E5%92%8C/","title":"P0004前缀平方和"},{"content":"这明显是一个满足答案单调性的二分。\n对于暴力思路 由于不知道极差最小为多少，那我们就考虑把极差从最小的枚举到最大，假如枚举到当极差为 $i$ 时满足可以在分成 $k$ 个组，那么就输出当前极差并退出循环。 当然这样不会保证答案的最优，有一个性质，就是让身高相似的同学尽量挨着，一个快排就可以办到。 不过这样的做法是 $O(n^2)$ ，超时。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 101001; const int MAX_i = 1e9 - 1; int a[N]; int n, k, ans; bool check(int x) // 判断当极差为x时是否可以满足条件 { int sum = 1, s = a[1]; // 分成几组，当前小组最低身高 for (int i = 2; i \u0026lt;= n; i++) { if (a[i] - s \u0026gt; x) // 需要以a[i]为最低身高新建一个小组 { sum++; s = a[i]; } if (sum \u0026gt; k) return 0; } return 1; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; sort(a + 1, a + n + 1); // 快排，满足学生身高从低到高 for (int i = 0; i \u0026lt;= MAX_i; i++) // 从0枚举到最大身高差 { if (check(i)) { cout \u0026lt;\u0026lt; i; break; } } return 0; } 发现当枚举答案时，满足单调性，即答案是依次从小的开始选择，直到找到合适的，即可以对选择答案这个过程进行二分，其余代码不需要修改。\n二分代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 101001; const int MAX_i = 1e9 - 1; int a[N]; int n, k, ans; bool check(int x) // 判断当极差为x时是否可以满足条件 { int sum = 1, s = a[1]; // 分成几组，当前小组最低身高 for (int i = 2; i \u0026lt;= n; i++) { if (a[i] - s \u0026gt; x) // 需要以a[i]为最低身高新建一个小组 { sum++; s = a[i]; } if (sum \u0026gt; k) return 0; } return 1; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; sort(a + 1, a + n + 1); // 快排，满足学生身高从低到高 int l = 0, r = MAX_i; while (l \u0026lt;= r) { int mid = (l + r) / 2; if (check(mid)) r = mid - 1, ans = mid; else l = mid + 1; } cout \u0026lt;\u0026lt; ans; return 0; } 时间复杂度 $O(nlogn)$\n","date":"2024-10-01T17:19:08+08:00","permalink":"http://localhost:1313/p/p0003%E6%8B%8D%E7%85%A7%E5%88%86%E7%BB%84/","title":"P0003拍照分组"},{"content":"定义 二分查找（英语：binary search），也称折半搜索（英语：half-interval search）、对数搜索（英语：logarithmic search），是用来在一个有序数组中查找某一元素的算法。\n过程 以在一个升序数组中查找一个数为例。\n它每次考察数组当前部分的中间元素，如果中间元素刚好是要找的，就结束搜索过程；如果中间元素小于所查找的值，那么左侧的只会更小，不会有所查找的元素，只需到右侧查找；如果中间元素大于所查找的值同理，只需到左侧查找。\n示例概念 二分是什么概念呢，举个例子，比如你在心里想一个 $1000$ 以内的正整数，让我猜，我每次猜一个数，你需要回答大了还是小了，这样，我可以做到最多 $10$ 次我就可以猜到这个数字是多少。 它的猜数路线是这样的，比如你猜的一个数是 $147$ ，我第一次猜 $500$ ，发现是大了，那么下次我猜的范围就是 $1-499$ ，我再猜 $250$ ，那么下次范围就是 $1-249$ ，再猜 $125$ ，下次范围是 $126-149$ ，再猜 $138$ ，下次范围 $139-149$ ，再猜 $144$ ，下次范围就是 $145-149$ ，再猜 $147$ ，这样就猜中了，只用了 $6$ 次就出结果了。换成 $1000$ 以内的任何数都是这样，都可以保证在 $10$ 次以内猜中。倘若一个个的试探的话，最坏可能会 $1000$ 次才能猜出来结果。这样对比二分的效率就来了，对应到代码上：\n非二分 1 2 3 4 5 6 7 8 9 10 int x; cin\u0026gt;\u0026gt;x;//要猜的数 for(int i=1;i\u0026lt;=1000;i++) if(i==x) { cout\u0026lt;\u0026lt;\u0026#34;猜对了\u0026#34;; break; } 二分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int x; cin\u0026gt;\u0026gt;x;//要猜的数 int l=1,r=1000;//猜数的左右边界 while(l\u0026lt;=r) { int mid = (l+r)/2;//每次猜的数是中间值，依次可以对半划分范围 if (mid==x){ cout\u0026lt;\u0026lt;\u0026#34;猜对了\u0026#34;; break; } if (mid\u0026gt;x) r=mid-1;//mid比x大，说明下次猜数要从 [l,mid-1]中选择 else l=mid+1; //mid比x小，说明下次猜数要从 [mid+1,r]中选择 } 那么假设我们猜的数范围是 $[1,n]$ ，那么非二分的做法时间复杂度就是 $O(n)$ ，而对于二分做法，每次猜都会缩减一半的范围，一直缩到范围为这个数本身，那么设时间为 $t$ ，那么 ， $2^t=n,t=\\log_2(n)$，即时间复杂度为 $O(log(n))$ 。\n如何观察到需要用二分 观察上个例子，为什么二分可以比一个个查询的速度快，其实就是它舍弃了一些不用查的数据，而且可以保证这部分数据绝对不会在答案中，而如何可以保证我们舍弃的数据绝对不会被查到，所以需要满足单调性，对于这个猜数问题它满足的是数据的单调性，还有一种单调性是状态决策的单调性（即答案的单调性），例题：P0003 拍照分组。\n当一个状态的决策过程或者序列满足单调性它往往可以考虑使用二分来解决。\nSTL 形式：\nlower_bound(a,a+n,x)-a; 表示在 $a$ 数组中找到第一个大于等于 $x$ 数的位置。 upper_bound(a,a+n,x)-a; 表示在 $a$ 数组中找到第一个大于 $x$ 数的位置。 参考模版 1 2 3 4 5 6 7 8 9 int l=1;r=n; int ans;//个人习惯，ans表示当前答案满足时的最优解 while(l\u0026lt;=r) { int mid=(l+r)\u0026gt;\u0026gt;1; if(check(mid)) l=mid+1,ans=mid; else r=mid-1,ans=mid; } 洛谷训练提单\n参考：二分 - OI Wiki ","date":"2024-10-01T16:51:20+08:00","permalink":"http://localhost:1313/p/%E4%BA%8C%E5%88%86/","title":"二分"},{"content":"LIS ：最长单调上升子序列。 LCS：最长公共子序列。\nLIS 考虑 $O(n)$ 单调上升子序列， 易得出一下代码，\n1 2 3 4 5 6 7 8 9 for(int i=1;i\u0026lt;=n;i++) { f[i]=1; for(int j=1;j\u0026lt;i;j++) { if(a[i]\u0026gt;=a[j]) f[i]=max(f[i],f[j]+1); } } 可优化为 $O(nlogn)$，考虑单调栈，每次往栈内压入一个 $x$ 保证 $f_{j\u0026rsquo;\u0026rsquo;}\u0026lt;x\u0026lt;f_{j\u0026rsquo;},j\u0026rsquo;\u0026rsquo;\u0026lt;j\u0026rsquo;$ ，所以原来栈内元素中把 $f_{j\u0026rsquo;}$ 弹出用 $x$ 替换掉，即 $f_{j\u0026rsquo;}=x$ 。保证栈内单调，且优先每个最大子段数保证递增的末尾数值尽可能的小。 而如何求出来 $j\u0026rsquo;$ ，一种是模拟的求，$O(n)$，由于栈内保证单调，所以也可以二分求出来 $O(logn)$ 。 当然一般会用 $k=lower_bound(f+1,f+t+1,x)-f$ 来求。 代码展示\n1 2 3 4 5 6 for (int i = n; i \u0026gt;= 1; i--) { int k = upper_bound(f + 1, f + ans + 1, a[i]) - f; f[k] = a[i]; ans = max(ans, k); } LCS 首先考虑朴素的公共子序列问题 典型的区间 $dp$ 问题\n1 2 3 4 5 6 7 8 for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= m; j++) { dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); if (a1[i] == a2[j]) dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + 1); // 因为更新，所以++； } 回文也可以简单的理解为颠转顺序来求正反串的最大公共子序列。 考虑找到最大公共子序列，用强制定义顺序，来使 LCS转换成LIS问题。\n对于任意两段数字内容序列，首先将其离散化，对任意序列强行定义顺序，在将另一序列用定义的顺序替换即可。 $for$ $example$ 3 2 1 4 5 4 2 3 5 1 将第二个队列用 1 2 3 4 5强行定义递增顺序，第一队列按照第二队列对应的方式一一映照即可。 得出3 2 5 1 4 然后再在3 2 5 1 4中找LIS就是该两队列中的LCS。 映射代码：\n1 2 3 4 5 6 for (int i = 1; i \u0026lt;= n; i++) { int x; cin\u0026gt;\u0026gt; x; v[x] = i; } ","date":"2024-09-25T22:02:59+08:00","permalink":"http://localhost:1313/p/lis%E5%92%8Clcs%E9%97%AE%E9%A2%98/","title":"LIS和LCS问题"},{"content":"$KMP$ 算法中的 $.next$ 数组本质就是求最长的相同前后缀的长度。 对于一般的字符串匹配，需要进行朴素的遍历，$kmp$ 算法是保证被遍历的字符串不动，让子串按照$.next$ 数组进行遍历。 主串是 $O(n)$ 遍历的，在遍历时只需要判断是否可以相等，相等的话持续下去，不相等的话跳到 $.next$ 数组对应的位置。 $.next$ 数组求法本质上是子串自己遍历子串\n1 2 3 4 5 6 7 8 9 string s; int j=0;//可以理解为子链上的指针 for(int i=2;i\u0026lt;=length;i++)//第一个不能被本身遍历，要不然就是整个串遍历完了 { while(j\u0026amp;\u0026amp;s[j+1]!=s[i])//j=0就是起始点了不用跳了，另一种是跳的过程中发现可以匹配上，也退出 j=kmp[j];//如果发现j+1无法匹配的时候就跳到.next数组的地方 if(s[j+1]==s[i])j++;//即匹配成功，子链向后移动 kmp[i]=j;//以i点为后缀，可以找到最大的相同的前缀 } $ABABCABBABCA$ 0 0 1 2 0 1 2 0 1 2 0 1\n那么遍历主串就简单多了\n1 2 3 4 5 6 7 8 9 string a,b; int j=0; for(int i=1;i\u0026lt;=la;i++) { while(j\u0026amp;\u0026amp;b[j+1]!=a[i])j=kmp[j]; if(a[i]==b[j+1])j++; //可以选择继续遍历下去，也可以在j==lb的时候直接退出 if(j==lb)j=kmp[j]; } 总之，时常练习，别忘了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int kmp[213123123]; string a,b; int main () { getline(cin,a);getline(cin,b); int la=a.size(); int lb=b.size(); int j=-1;kmp[0]=-1; for(int i=1;i\u0026lt;lb;i++) { while(j\u0026gt;=0\u0026amp;\u0026amp;b[j+1]!=b[i])j=kmp[j]; if(b[j+1]==b[i])j++; kmp[i]=j; } //for(int i=0;i\u0026lt;lb;i++)cout\u0026lt;\u0026lt;kmp[i]+1\u0026lt;\u0026lt;\u0026#34; \u0026#34;; j=-1; for(int i=0;i\u0026lt;la;i++) { while(j\u0026gt;=0\u0026amp;\u0026amp;a[i]!=b[j+1])j=kmp[j]; if(b[j+1]==a[i])j++; if(j==lb-1){cout\u0026lt;\u0026lt;i-lb+2\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;;} } for(int i=0;i\u0026lt;lb;i++)cout\u0026lt;\u0026lt;kmp[i]+1\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } ","date":"2024-09-25T22:01:06+08:00","permalink":"http://localhost:1313/p/kmp%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/","title":"KMP字符串匹配"},{"content":" 嗯！ 题目有P3371 【模板】单源最短路径（弱化版），P4779 【模板】单源最短路径（标准版）。\n之后还有个Dijkstra的反复横跳的大水题P4943（哈利与罗恩的奇妙冒险）。\n还是分析一下这个算法吧。\n这边说一下我不会画电子版的图所以就看我的语文功底好不好吧。\n存在二维的最短路小红走矩阵)\n建图 对于一个图，首先得确定拿什么方式来建图和存图。\n刚开始可能会拿邻接矩阵来搞（然后就发现“茫茫世间，尽是大漠一片”）\n看过深入浅出的可能会拿vector数组来存，但是不方便。\n还有拿链式表，还有拿前向星的，这两个都很好就是各自都有互补的缺点，于是乎就有了“链式前向星”。\n关于前向星的思路我大概叙述一下，网上有很多的讲解比我的都好。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int n,m,cnt; struct Edge { int to,w,next; }edge[maxn]; int head[maxn]; void init () { for(int i=0;i\u0026lt;=n;i++)head[i]=-1; cnt=0; } void add_edge(int u,int v,int w) { edge[cnt].to=v; edge[cnt].w=w; edge[cnt].next=head[u]; head[u]=cnt++;//这个是先让head[u]=cnt，然后让cnt=cnt+1； } 这个东西是以边cnt来存路径的，三个点u,v,w，分别为起点，终点，权值。而.next为下（亦可以理解为上一条边）一条边，head数组就是以某一个点u连接的某些边的集合，这个要将每个顶点连的第一条边都赋值为“-1”，因为当所有的边都遍历完了，“-1”就是退出循环的标志。\n每个序号有唯一的边，但每个边不一定只有一个序号来对应就像函数y（边）和x（序号）的关系。\n枚举过程是以某个边cnt连接的起点来枚举这个点的所有边，但不用存有几条边，因为最后会连接到\u0026quot;-1\u0026quot;就终止循环了。\n这是枚举用的代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 for(int i=1;i\u0026lt;=n;i++) { cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; for(int j=head[i];j!=-1;j=edge[j].next) { cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;edge[j].to\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;edge[j].w\u0026lt;\u0026lt;endl; } cout\u0026lt;\u0026lt;endl; } for (int i = 1; i \u0026lt;= n; i++) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; for (int j = h[i]; j != -1; j = e[j].nt) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; e[j].to \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; } 然后我们来考虑Dijkstra的算法分析。\nDijkstra 问题:以某个点s为起点到该图所有的点的最小权值。\n看图工具\n造个数据,\n1 2 5 1 5 2 1 3 1 1 4 3 2 5 1 3 2 1 3 4 1 （比较拉跨）\n对于这个图从$1$可以到4个点，然后我们枚举四个点的权值，之后该干嘛？\n答：找最小值。因为当某个路径的权值是所有路径中最小值的时候，那么它就更有重复被其他点当作路径的可能。\n比如：1-\u0026gt;4直接走权值就是3，但是1-\u0026gt;3-\u0026gt;4权值只有2，也就是dis[1-\u0026gt;3]+dis[3-\u0026gt;4]\u0026lt;dis[1-\u0026gt;4],则dis[1-\u0026gt;4]=dis[1-\u0026gt;3]+dis[3-\u0026gt;4]。\n这时比较聪明的就立刻举手，从1-\u0026gt;2是5而1-\u0026gt;5-\u0026gt;2只有3。不过1-\u0026gt;3-\u0026gt;2只有2，所以它的最小权值就是2。\n这样就是先走最小的边，然后再考虑后面的边，这样就可能得到的路径的权值比原来的更小。\n不过一旦我们找到到达这个点的最小值了，那么就不需要考虑到达的这个点的枚举了，所以就需要用$visit$数组做一个标记，这个点到过了就标记一下下一个点就不会再重复枚举了。\n我们把这个点对应的路径的权值都算出来，然后找最小的权值对应的点再枚举路径再找到最小的点，直到该点所连接的点均到过就结束循环。\n所以这个的大体思路就有了，就是先找一个点，然后把这个点的所有边都枚举一遍找到最小值的路径对应的点并标记一下，再枚举一遍这个点对应的边，再次找到最小值，再枚举。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void Dijkstra() { int minn,pos; while(1) { minn=inf,pos=-1; for(int i=1;i\u0026lt;=n;i++) { if(!visit[i]\u0026amp;\u0026amp;dis[i]\u0026lt;minn) { minn=dis[i],pos=i; } } if(pos==-1)break; visit[pos]=1; for(int i=h[pos];i!=-1;i=edge[i].next) { int t=edge[i].to; if(!visit[t]\u0026amp;\u0026amp;dis[t]\u0026gt;dis[pos]+edge[i].w) dis[t]=dis[pos]+edge[i].w; } } return ; } 但是， 这样不会太慢吗，每次都得作比较，就跟我的快排艺术差不多了。\n所以这边就需要用到优先队列。\n首先先说明优先队列是干什么的。\n它就是可以简单的理解为你往队列里面堆入一个值它可以将这个值按照你的定义来排序（比如：从大到小或者从小到大）。\n而这个是怎么实现的呢？就是在结构体里面自定义一下。\n1 2 3 4 5 6 7 struct nihao{ int a;int b; bool operator\u0026lt;(const nihao \u0026amp; u) const { return a\u0026gt;u.a; } }m; 这里面const nihao \u0026amp; u指的是往这个队列里堆入一个结构类型为nihao的变量，让这个变量的.a和这个队列里的.a的数作比较返回一个大的值也就是从大到小排序。\n而对于Dijkstra则是从小到大的排序，也就是用了优先队列就不用一个个的比最小值了，只需要把这个数据堆入自动排序，如果用的时候再弹出队列就行了。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void Dijkstra() { while(!q.empty()) { node temp=q.top(); q.pop(); int x=temp.pos,d=temp.dis; if(!visit[x]) { visit[x]=1; for(int i=h[x];i!=-1;i=edge[i].next) { int t=edge[i].to; if(!visit[t]\u0026amp;\u0026amp;dis[t]\u0026gt;dis[x]+edge[i].w) dis[t]=dis[x]+edge[i].w,q.push((node){dis[t],t}); } } } return ; } 以上就叙述完了。\n所以一个Dijkstra的完整代码搁这了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;algorithm\u0026gt; #define mm 20000001 #define inf 0x7fffffff using namespace std; int n,m,s,cnt; int h[2000001],dis[mm]; bool visit[mm]; struct Edge{ int to,w,next; }edge[2000001]; struct node { int dis; int pos; bool operator \u0026lt;( const node \u0026amp;x )const { return x.dis \u0026lt; dis; } }; priority_queue\u0026lt;node\u0026gt;q; void init () { memset(visit,0,sizeof(visit)); memset(dis,0x3f,sizeof(dis)); memset(h,-1,sizeof(h)); } void add(int u,int v,int w) { edge[cnt].to=v,edge[cnt].w=w,edge[cnt].next=h[u],h[u]=cnt++; } void pintf() { for(int i=1;i\u0026lt;=n;i++) { cout\u0026lt;\u0026lt;dis[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } } void Dijkstra() { while(!q.empty()) { node temp=q.top(); q.pop(); int x=temp.pos,d=temp.dis; if(!visit[x]) { visit[x]=1; for(int i=h[x];i!=-1;i=edge[i].next) { int t=edge[i].to; if(!visit[t]\u0026amp;\u0026amp;dis[t]\u0026gt;dis[x]+edge[i].w) dis[t]=dis[x]+edge[i].w,q.push((node){dis[t],t}); } } } return ; } int main () { cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;s; init(); for(int i=1;i\u0026lt;=m;i++) { int a,b,c; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c; add(a,b,c); } dis[s]=0; q.push((node){0,s}); Dijkstra(); pintf(); return 0; } OVER!\n","date":"2024-09-25T21:54:41+08:00","permalink":"http://localhost:1313/p/%E6%9C%80%E7%9F%AD%E8%B7%AF-dijkstra/","title":"最短路 Dijkstra"},{"content":"循环与数组\n字符串结构体函数\n二分\n最短路-Dijkstra\nKMP字符串匹配\nLIS和LCS问题\n","date":"2024-09-25T21:53:01+08:00","permalink":"http://localhost:1313/p/%E7%AE%97%E6%B3%95%E5%A4%A7%E7%BA%B2/","title":"算法大纲"},{"content":"QAQ/꒰ঌ( 🎀ᗜ`˰´ᗜ🌸 )໒꒱💈× 出题人题解 题意：有 $n$ 个人正在发癫，已知有 $m$ 个它们可能对着发癫的 Vtuber 且每个人有两个推的 Vtuber ，保证这两位 Vtuber 不同且没有任意两个人推的两位 Vtuber 完全一致，这些人只有可能对着自己推的 Vtuber 发癫。\n试问有没有可能每个人对着发癫的 Vtuber 各不相同，若有，请给出一种可能的情况。\n多测，$T\\le 10^5,\\sum n,\\sum m \\le 2\\times 10 ^6$。\n子任务分布如下：\n20分算法： 直接爆搜 $2^n$ 种可能的情况，每次 $\\Theta(m)$ 判断。\n时间复杂度 $\\Theta(\\sum m2^n)$，视常数和剪枝情况可以拿到 $20-25$ 分。\n50分算法： 我们考虑在 Vtuber 和颠佬之间连边，将两者分别视作二分图的左部与右部，求整张图的二分图最大匹配，当匹配数为 $n$ 时即为合法，输出求出的任意一种匹配即可。\n考虑匈牙利算法，整张图的点数为 $n+m$，边数为 $2n$ ，时间复杂度为 $\\Theta(n^2+nm)$ 级别。\n加上卡常，实际最多可以获得 $60$ 分。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 //written by Amekawa_kanade #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; void syncoff()//fuck you sync { ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); } #define endl \u0026#39;\\n\u0026#39; const int N=6e6+11; using ll=long long; using i128=__int128; using ld=long double; const ll JT=998244353; const ll GEH=1e9+7; const ll ZLH=1e9+9; const int inf=INT_MAX-1; int t,n,k,m,q; struct edge { int to,nxt; }G[N*2];int cnt1,H1[N],vnm;bool vis[N]; int gt[N]; void add_edge(int u,int v) { G[cnt1]=edge{v,H1[u]};H1[u]=cnt1++; } void add_r(int u,int v) { add_edge(u,v),add_edge(v,u); } bool augment(int u) { for(int i=H1[u];i!=-1;i=G[i].nxt) { int v=G[i].to; if(!vis[v]) { vis[v]=1; if(!gt[v]||augment(gt[v])) { gt[v]=u; gt[u]=v; return 1; } } } return 0; } void clear() { for(int i=1;i\u0026lt;=vnm;++i) vis[i]=gt[i]=0; cnt1=0,vnm=0; } int _s,_t; void solve() { cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vnm=n+m;for(int i=1;i\u0026lt;=vnm;++i) H1[i]=-1; for(int i=1;i\u0026lt;=n;++i) { int iu,iv;cin\u0026gt;\u0026gt;iu\u0026gt;\u0026gt;iv; add_edge(i,iu+n); add_edge(i,iv+n); } int chk=0; for(int i=1;i\u0026lt;=n;++i) fill(vis+1,vis+vnm+1,0),chk+=augment(i); if(chk\u0026lt;n) { cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl;return clear(); } else cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;\u0026lt;\u0026lt;endl; //for(int i=0;i\u0026lt;=cnt1;++i) cout\u0026lt;\u0026lt;G[i].to\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;endl; for(int i=1;i\u0026lt;=n;++i) { cout\u0026lt;\u0026lt;gt[i]-n\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } cout\u0026lt;\u0026lt;endl; return clear(); } void file(string file) { freopen((file+\u0026#34;.in\u0026#34;).c_str(),\u0026#34;r\u0026#34;,stdin); freopen((file+\u0026#34;.out\u0026#34;).c_str(),\u0026#34;w\u0026#34;,stdout); } /* 1 5 5 1 3 4 5 2 5 1 4 3 5 */ int main() { //file(\u0026#34;19\u0026#34;); syncoff(); cin\u0026gt;\u0026gt;t; while(t--) solve(); return 0; } 特殊性质：B 考虑给出 $n+m$ 个点的图，随机在左右两部连 $2n$ 条不重的边，让左部每一个点都能够得到匹配的概率极低。\n又考虑到这些测试点的 $T$ 都很小，我们大胆猜测：此时有极大的概率无解。\n我们考虑卡时或直接特判 $T=2$ 或 $T=6$ ，直接全部输出 NO 。\n60分算法： 我们考虑一些治标不治本的东西：加速二分图最大匹配。\n二分图最大匹配可以转换成最大流：源点往所有左部点连一条弧，左部与右部的边替换为由左部往右部连的一条弧，右部每个点往汇点连一条弧，所有弧的容量均设为 $1$ ，这张网络的最大流即为二分图最大匹配数，查看匹配只需要看反向弧流量。\n这种网络的点数与弧数均为 $n+m$，使用Dinic算法可以做到 $\\Theta((n+m)\\sqrt {n+m})$ 的时间复杂度。\n相信Dinic算法的优秀常数，卡卡常，下面给出实际得分 $75$ 分的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 //written by Amekawa_kanade #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; void syncoff()//fuck you sync { ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); } #define endl \u0026#39;\\n\u0026#39; const int N=6e6+11; using ll=long long; using i128=__int128; using ld=long double; const ll JT=998244353; const ll GEH=1e9+7; const ll ZLH=1e9+9; const int inf=INT_MAX-1; int t,n,k,m,q; struct edge { int to,nxt,cap; }G[N*2];int cnt1,H1[N],vnm;vector\u0026lt;int\u0026gt; dis,rad; void add_edge(int u,int v,int val) { G[cnt1]=edge{v,H1[u],val};H1[u]=cnt1++; } void add_r(int u,int v,int val) { add_edge(u,v,val),add_edge(v,u,0); } bool delaminate(int s,int t) { fill(dis.begin(),dis.end(),0); dis[s]=1;queue\u0026lt;int\u0026gt; que;que.push(s); while(!que.empty()) { auto u=que.front();que.pop();rad[u]=H1[u]; for(int i=H1[u];i!=-1;i=G[i].nxt) { int v=G[i].to; if(!dis[v]\u0026amp;\u0026amp;G[i].cap) dis[v]=dis[u]+1,que.push(v); } } return dis[t]; } int augment(int u,int ref,int t) { if(u==t||!ref) return ref;int nrf=ref; for(int i=H1[u];i!=-1\u0026amp;\u0026amp;nrf;i=G[i].nxt) { int v=G[i].to;rad[u]=i; if(dis[v]==dis[u]+1\u0026amp;\u0026amp;G[i].cap) { int aug_min=min(G[i].cap,nrf),dlta=augment(v,aug_min,t); G[i].cap-=dlta,G[i^1].cap+=dlta;nrf-=dlta; if(!nrf) break; } } return ref-nrf; } int dinic(int s,int t) { int ans=0; while(delaminate(s,t)) ans+=augment(s,inf,t); return ans; } void clear() { //for(int i=1;i\u0026lt;=vnm;++i) H1[i]=-1; cnt1=0,vnm=0; } int _s,_t; void solve() { cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;_s=1,_t=n+m+2; vnm=2+n+m;for(int i=1;i\u0026lt;=vnm;++i) H1[i]=-1; for(int i=2;i\u0026lt;=n+1;++i) add_r(_s,i,1); for(int i=n+2;i\u0026lt;=n+m+1;++i) add_r(i,_t,1); dis=vector\u0026lt;int\u0026gt;(vnm+2,0); vector\u0026lt;int\u0026gt; oprs[2];rad=vector\u0026lt;int\u0026gt;(vnm+2,0); oprs[0].resize(n+1),oprs[1].resize(n+1); for(int i=1;i\u0026lt;=n;++i) { int iu,iv;cin\u0026gt;\u0026gt;iu\u0026gt;\u0026gt;iv; //cout\u0026lt;\u0026lt;iu+n+1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;iv+n+1\u0026lt;\u0026lt;endl; oprs[0][i]=cnt1;add_r(i+1,iu+n+1,1); oprs[1][i]=cnt1;add_r(i+1,iv+n+1,1); } int chk=dinic(_s,_t);//cout\u0026lt;\u0026lt;chk\u0026lt;\u0026lt;endl; if(chk\u0026lt;n) { cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl;return clear(); } else cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;\u0026lt;\u0026lt;endl; //for(int i=0;i\u0026lt;=cnt1;++i) cout\u0026lt;\u0026lt;G[i].to\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;endl; for(int i=1;i\u0026lt;=n;++i) { int e0=oprs[0][i],e1=oprs[1][i]; assert((e0\u0026amp;1)==0);assert((e1\u0026amp;1)==0); if(G[e0^1].cap) cout\u0026lt;\u0026lt;G[e0].to-1-n\u0026lt;\u0026lt;\u0026#39; \u0026#39;; else cout\u0026lt;\u0026lt;G[e1].to-1-n\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } cout\u0026lt;\u0026lt;endl; return clear(); } void file(string file) { freopen((file+\u0026#34;.in\u0026#34;).c_str(),\u0026#34;r\u0026#34;,stdin); freopen((file+\u0026#34;.out\u0026#34;).c_str(),\u0026#34;w\u0026#34;,stdout); } /* 1 5 5 1 3 4 5 2 5 1 4 3 5 */ int main() { syncoff(); cin\u0026gt;\u0026gt;t; while(t--) solve(); return 0; } 特殊性质：A 我们考虑构出这种图：每个右部点的度数最大也为 $2$，原图可以分解为若干条夹杂着左右部点的链，并且一定满足 $n\\le m$，因此此时一定有解，解也容易构造，可以在线性时间内处理。\n特判所有右部点的度数即可处理这种特殊情况。\n有趣的是，Dinic算法跑这种情况嘎嘎快，并不需要特殊处理就可以通过。\n缝合 如果您只会爆搜，只要敢于不可以总司令，搞定特殊性质B，可以拿到 $35$ 分。\n如果您想到了二分图但不会网络流，并且敢于大胆不可以总司令，您可以再拿 $5$ 分整到最多 $60$ 分。如果还能搞定特殊性质A，您还可以再搞 $10$ 分。\n如果您是网络流领域大神，并且写了Dinic，特殊性质A的点直接可过，加上一个不可以总司令，$80$ 分到手。\n正解 通过特殊性质A的链状结构，我们发现：链的两个端点一定是代表Vtuber的右部点，并且代表颠佬的左部点总是被两个右部点夹在中间。\n进一步思考一般情况，发现后者对所有情况都成立。\n我们从特殊性质A考虑：实际上解的构造就是对每个左部点选择其两端的任意一个右部点端点，使每个右部点最多被选择一次。\n由此，我们重新建图：把Vtuber看成点，每个颠佬看成连在他推的两个Vtuber之间的边，选择某个Vtuber则视为将这条边定向为指向那个Vtuber，那么，存在解的充要条件就成为了：存在一种给边定向的方案，使每个点的入度均不超过 $1$。\n我们冷静思考下这个条件，发现单个连通分量能满足这个条件时，它要么是树，要么是基环树。\n因此，此时有解的充要条件转化为：该图的所有连通分量要么是树要么是基环树。\n首先是判定：直接对每个连通分量求出点数和边数，若满足 $\\mid E\\mid \\le \\mid V\\mid$ ，不等时为树，相等时为基环树。\n如果有解，构造算法如下：对于树，直接任找一个点作为根，边定向为叶向树即可。\n对于基环树，先不考虑环上的边，以环为根，将所有边都定为叶向：对于环上的边，全部取一个方向即可。\n以上所有步骤均可以通过DFS在线性时间内完成，时间复杂度 $\\Theta(n+m)$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 //written by Amekawa_kanade #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; void syncoff()//fuck you sync { ios::sync_with_stdio(0); cin.tie(0);cout.tie(0); } #define endl \u0026#39;\\n\u0026#39; const int N=2e6+11; using ll=long long; int t,n,k,m,q; struct edge { int to,nxt,id; }G[N*2];int cnt1=1,H1[N]; inline void add_edge(int u,int v,int id) { G[++cnt1]=edge{v,H1[u],id};H1[u]=cnt1; } int cid,vcnt[N],ecnt[N],cidu[N]; bitset\u0026lt;N\u0026gt; vis; bool evis[N*2]; #define RAPE(i,x) for(int i=H1[x];i;i=G[i].nxt) void dfs1(int u,int f,int id) { ++vcnt[id];vis[u]=1; RAPE(i,u) { auto v=G[i].to; if(i==(f^1)||evis[i]) continue; evis[i]=evis[i^1]=1; ++ecnt[id];if(!vis[v]) dfs1(v,i,id); } } int idx,dfn[N],fa[N]; vector\u0026lt;int\u0026gt; loops[N]; void find_loop(int u,int id) { dfn[u]=++idx; RAPE(i,u) if(G[i].to!=fa[u]) { auto v=G[i].to; if(dfn[v]\u0026amp;\u0026amp;dfn[v]\u0026gt;dfn[u]) { loops[id].push_back(v); vis[v]=1; auto y=v; while(y!=u) { loops[id].push_back(fa[y]); vis[fa[y]]=1; y=fa[y]; } } else if(!dfn[v]) { fa[v]=u;find_loop(v,id); } } } int ans[N]; void dfs2(int u,int f) { RAPE(i,u) { auto v=G[i].to; if(v==f||vis[v]) continue; //cout\u0026lt;\u0026lt;G[i].id\u0026lt;\u0026lt;\u0026#34;:\u0026#34;\u0026lt;\u0026lt;v\u0026lt;\u0026lt;endl; ans[G[i].id]=v;dfs2(v,u); } } bitset\u0026lt;N\u0026gt; vis2; void dfs3(int u,int f,int id) { vis2[u]=1; RAPE(i,u) { auto v=G[i].to; if(v==f) continue; if(v==id) { ans[G[i].id]=id;return; } if(vis2[v]||!vis[v]) continue; ans[G[i].id]=v;//cout\u0026lt;\u0026lt;G[i].id\u0026lt;\u0026lt;\u0026#34;::\u0026#34;\u0026lt;\u0026lt;v\u0026lt;\u0026lt;endl; dfs3(v,u,id); } } void clear() { for(int i=1;i\u0026lt;=cnt1+11;++i) evis[i]=0; for(int i=1;i\u0026lt;=n;++i) fa[i]=dfn[i]=H1[i]=vis[i]=vis2[i]=0;idx=0; cnt1=1; for(int i=1;i\u0026lt;=m;++i) ans[i]=0; for(int o=1;o\u0026lt;=cid;++o) { loops[o].clear(); vcnt[o]=ecnt[o]=0; cidu[o]=0; } cid=0; } void solve() { cin\u0026gt;\u0026gt;m\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=m;++i) { int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v;//cout\u0026lt;\u0026lt;u\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;v\u0026lt;\u0026lt;endl; add_edge(u,v,i);add_edge(v,u,i); } if(n\u0026lt;m) { cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl; clear(); return; } for(int i=1;i\u0026lt;=n;++i) if(!vis[i]) dfs1(i,-1,++cid),cidu[cid]=i; for(int i=1;i\u0026lt;=cid;++i) { //cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;ecnt[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;vcnt[i]\u0026lt;\u0026lt;endl; if(ecnt[i]\u0026gt;vcnt[i]) { clear(); cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl; return; } } for(int i=1;i\u0026lt;=n;++i) vis[i]=0; for(int i=1;i\u0026lt;=cid;++i) { if(!vcnt[i]) continue; else if(vcnt[i]==ecnt[i]) { find_loop(cidu[i],i); for(auto x:loops[i]) dfs2(x,0); auto rtp=loops[i][0]; dfs3(rtp,0,rtp); } else dfs2(cidu[i],0); } cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;\u0026lt;\u0026lt;endl; for(int i=1;i\u0026lt;=m;++i) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;;cout\u0026lt;\u0026lt;endl; clear(); //fflush(stdout); } void file(string file) { freopen((file+\u0026#34;.in\u0026#34;).c_str(),\u0026#34;r\u0026#34;,stdin); freopen((file+\u0026#34;.out\u0026#34;).c_str(),\u0026#34;w\u0026#34;,stdout); } int main() { syncoff(); //file(\u0026#34;11\u0026#34;); cin\u0026gt;\u0026gt;t;//cout\u0026lt;\u0026lt;t\u0026lt;\u0026lt;endl; while(t--) solve(); return 0; } /* 5 5 1 3 4 5 2 5 1 4 3 5 */ 题外话 本题的checker实现：首先用 std 生成该测试点的判定文件，这个判定文件说明测试点的每个子任务是否有解。\nchecker首先读取这个判定文件，之后对于每个测试点，先对照是否有解，若有解且回答正确，对于方案的判定就是爆搜那一套。\n","date":"2024-09-23T22:01:23+08:00","permalink":"http://localhost:1313/p/p0011/","title":"P0011"},{"content":"这个问题一眼看是一个排列组合问题，但是由于限制条件 $k$ 的关系，不能直接通过乘积得到，观察题意发现，求得是对方案数取模，这样如果直接用乘法原理往往需要用到逆元，所以一般这样方案数，就考虑 $dp$。\ndp 状态定义 对于 $dp$ 问题，定义状态往往是最难的，状态的定义是否正确合理则决定了做法是否正确和简洁 ——一个我忘了哪个大佬说的 我开始设定的转态定义是 $dp_{i,j,k,0/1}$ 表示前 $i$ 个位置，放 $j$ 个黑球，以黑球 $(1表示黑球)$ 结尾，连续长度为 $k$ 的状态定义，后来发现状态定义是不正确的，因为发现可能会出现当 $k==3$ ，xxxoooxxx 会被理解为正确状态，所以舍弃。后来考虑 $dp_{i,j,Q,W}$ 表示前 $i$ 个位置，放 $j$ 个黑球，后缀为最大黑球比白球多 $Q$ 个，白球比黑球多 $W$ 个，这个转态定义可以把每种状态都包含进去，而且是正确的。\n状态正确性证明 当每添加一个黑球或白球，它构成的合法方案是由原来合法状态得来的，而它添进去的数的方案也必须合法，所以检验一个方案是否合法只需要检验新构成的方案是否合法即可，而新构成的方案必然造成的是对后缀的改变，那么只需要对后缀进行限制即可。该状态满足，所以状态正确。（感觉证明写的好像在水字数）\n由于 $i,j$ 表示前 $i$ 个位置有 $j$ 个黑球，本质上等价于前 $i+j$ 个位置上放了 $i$ 个黑球，$j$ 个白球，于是转态定义就更新成 $dp_{i,j,Q,W}$ 表示放 $i$ 个黑球，放 $j$ 个白球，后缀为最大黑球比白球多 $Q$ 个，白球比黑球多 $W$ 个\n状态转移 这次状态转移分为两个，一个是递推的转移，另一个是递归的记忆化搜索。\n递推的状态转移 初始转态：$dp_{1,0,1,0}=dp_{0,1,0,1}=1$，分别表示第一个球放入黑球还是白球的情况。\n转移：$dp_{i,j,q,w}=dp_{i-1,j,q-1,w+1}+dp_{i,j-1,q+1,w-1}$\n还有一种情况，当 $q==0$ 且要放入白球时，$dp_{i,j,0,w}+=dp_{i,j-1,0,w-1}$ 对于白球亦然，当 $w==0$ 且要放入黑球时，$dp_{i,j,q,0}+=dp_{i-1,j,q-1,0}$\n统计答案就是当黑白球都被填充进去，所有的合法方案数加在一起。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 101001; #define LL long long int n, m, K; LL ans; const int MOD = 1e9 + 7; LL dp[200][200][30][30]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; K; dp[1][0][1][0] = 1; dp[0][1][0][1] = 1; for (int i = 0; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt;= m; j++) { for (int q = 0; q \u0026lt;= K; q++) { for (int w = 0; w \u0026lt;= K; w++) { if (q \u0026gt;= 1 \u0026amp;\u0026amp; i \u0026gt;= 1) { dp[i][j][q][w] = (dp[i][j][q][w] + dp[i - 1][j][q - 1][w + 1]) % MOD; if (w == 0) dp[i][j][q][w] = (dp[i][j][q][w] + dp[i - 1][j][q - 1][0]) % MOD; } if (w \u0026gt;= 1 \u0026amp;\u0026amp; j \u0026gt;= 1) { dp[i][j][q][w] = (dp[i][j][q][w] + dp[i][j - 1][q + 1][w - 1]) % MOD; if (q == 0) dp[i][j][q][w] = (dp[i][j][q][w] + dp[i][j - 1][0][w - 1]) % MOD; } } } } } for (int i = 0; i \u0026lt;= K; i++) { for (int j = 0; j \u0026lt;= K; j++) { ans = (ans + dp[n][m][i][j]) % MOD; } } cout \u0026lt;\u0026lt; ans; return 0; } 递归的记忆化转移 对于状态 $dp_{i,j,Q,W}$ :\n当 $i\\leq n$ 且 $Q\\leq K$ 时可以放下白球，转移至 $dp_{i+1,j,Q+1,.max(0,W-1)}$ 当 $j\\leq m$ 且 $W\\leq K$ 时可以放下白球，转移至 $dp_{i,j+1,max(Q-1,0),W+1}$ 时间复杂度 $O(nmk^2)$\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 101001; const int mod = 1e9 + 7; typedef long long LL; LL dp[200][200][30][30]; int n, m, K; LL dfs(int i, int j, int q, int w) { if (i == n \u0026amp;\u0026amp; j == m) return 1; if (dp[i][j][q][w] != -1) return dp[i][j][q][w]; LL tmp = 0; if (i \u0026lt; n \u0026amp;\u0026amp; q \u0026lt; K) { tmp = (tmp + dfs(i + 1, j, q + 1, max(0, w - 1))) % mod; } if (j \u0026lt; m \u0026amp;\u0026amp; w \u0026lt; K) { tmp = (tmp + dfs(i, j + 1, max(0, q - 1), w + 1)) % mod; } return dp[i][j][q][w] = tmp; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; K; for (int i = 0; i \u0026lt;= n; i++) for (int j = 0; j \u0026lt;= m; j++) for (int q = 0; q \u0026lt;= K; q++) for (int w = 0; w \u0026lt;= K; w++) dp[i][j][q][w] = -1; cout \u0026lt;\u0026lt; dfs(0, 0, 0, 0); return 0; } ","date":"2024-09-18T20:59:19+08:00","permalink":"http://localhost:1313/p/p0010%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97/","title":"P0010你的名字"},{"content":"快排骗25pts。 用了个快排（循环内的），下面欣赏我低级的快排艺术\n1 for(int i=0;i\u0026lt;=n;i++) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 if(i!=0) { while(h\u0026lt;i) { h++;aa[h]=p[h].b; } sort(aa+1,aa+h+1); int qw=h; for(int f=1;f\u0026lt;=h;f++) { if(h\u0026gt;=m1)break;qw++; while(p[qw].a\u0026lt;aa[f]\u0026amp;\u0026amp;qw+1\u0026lt;=m1)qw++; if(qw\u0026lt;m1) { h++,aa[h]=p[qw].b,r++; } if(qw==m1){if(p[qw].a\u0026gt;=aa[f])h++;break; } sort(aa+r,aa+h+1); } } 本来就以为是 $ 20$ 分，没想到 $#16$ 竟然过了，所以拿了 $25$ 分。\n接下来是正题!!! 对于模拟的话， 我们只需要考虑模拟廊桥的数量当廊桥数有的就 $t++$,没有的直接舍去考虑下一个飞机，然后一直循环到结束。所以我们要先讲飞机的出发时间进行快排，在之后建立一个自定义的优先队列，用来维护结束时间最早的飞机，然后当下一个飞机来的出发时间时候和队列的 $top$ 作比较，如果大于就将其堆入队列，否则就是下一个飞机（注意模拟的是廊桥数所以要保证廊桥一直处于被占满的状态） 时间复杂度 $O(nm\\ logn)$，其实是 $40$ 分，可能 $CCF$ 数据有问题 $#16$ 就是能过（快排也行）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;queue\u0026gt; #define mm 1100000 using namespace std; int n,m1,m2,j,h,g,ans; struct nihao{ int a;int b; bool operator\u0026lt;(const nihao \u0026amp; u) const { return b\u0026gt;u.b; } }; nihao t[mm],p[mm]; int cmp(nihao x,nihao y) { return x.a\u0026lt;y.a; } int main () { scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;n,\u0026amp;m1,\u0026amp;m2); for(int i=1;i\u0026lt;=m1;i++) scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;p[i].a,\u0026amp;p[i].b); sort(p+1,p+m1+1,cmp); for(int i=1;i\u0026lt;=m2;i++) scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;t[i].a,\u0026amp;t[i].b); sort(t+1,t+m2+1,cmp); for(int i=0;i\u0026lt;=n;i++) { priority_queue\u0026lt;nihao\u0026gt; q; priority_queue\u0026lt;nihao\u0026gt; w; j=n-i,h=0,g=0; if(i) { while(h\u0026lt;i) { h++;q.push(p[h]); } int qw=h; while(q.size()==i){ if(h\u0026gt;=m1)break; qw++; while(p[qw].a\u0026lt;q.top().b\u0026amp;\u0026amp;qw+1\u0026lt;=m1)qw++; if(qw\u0026lt;m1)\th++,q.push(p[qw]),q.pop(); if(qw==m1){if(p[qw].a\u0026gt;=q.top().b)h++;break; } } } if(j) { while(g\u0026lt;j) { g++;w.push(t[g]); } int qw=g; while(w.size()==j){ if(g\u0026gt;=m2)break;qw++; while(t[qw].a\u0026lt;w.top().b\u0026amp;\u0026amp;qw+1\u0026lt;=m2)qw++; if(qw\u0026lt;m2) g++,w.push(t[qw]),w.pop(); if(qw==m2){if(t[qw].a\u0026gt;=w.top().b)g++;break; } } } if(h+g\u0026gt;ans)ans=h+g; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } 接下来就是正解了。 我们可以考虑两个优先队列进行维护。 一个维护廊桥的序号，另一个维护飞机的时间。 对于这个题我们求当每一个飞机到达机场时有几个廊桥是空余的（以飞机编号循环）， 如果有多个空余， 优先选择编号靠前的廊桥这样可以使飞机数最大化（要标记上它所在廊桥的编号）， 因为对于一个飞机所在廊桥的编号 $t$ ，在分配的廊桥数 $\u0026gt;=t$ 时，它都会停在那里。 让后就只需要开一个数组 $m$ 来求前缀和。（国外机场复制粘贴即可） 注意看注释（很重要）。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;queue\u0026gt; #define mm 1100000 using namespace std; int n,m1,m2,ans; int x[mm],y[mm]; struct nihao{ int a;int b; bool operator\u0026lt;(const nihao \u0026amp; u) const { return a\u0026gt;u.a; } }; pair\u0026lt;int,int\u0026gt; t[mm],p[mm]; int main () { scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;n,\u0026amp;m1,\u0026amp;m2); for(int i=1;i\u0026lt;=m1;i++) scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;p[i].first,\u0026amp;p[i].second); sort(p+1,p+m1+1); for(int i=1;i\u0026lt;=m2;i++) scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;t[i].first,\u0026amp;t[i].second); sort(t+1,t+m2+1); priority_queue\u0026lt;nihao\u0026gt; q;//a存结束时间 ，b存该飞机停在廊桥的编号 priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt; \u0026gt; k; for(int i=1;i\u0026lt;=m1;i++)k.push(i); for(int i=1;i\u0026lt;=m1;i++)// { /* 3 5 4// k1 3 k2 1 1 5 //1 3 8/6 //2 6 10 //1 9 14 //2 13 18 //1 k 1 2 1 2 1 q 5,1 8,2 10,1 14,2 18,1 */ while (!q.empty()\u0026amp;\u0026amp;q.top().a\u0026lt;=p[i].first) //找到可以的接的位置，因为这个飞机的时间是较后面都早的（本质是判断这个飞机到达时有多少个空缺的位置） { k.push(q.top().b);//意味着有个位置空出来了，而空出来的位置就是q队列里面最早离开的 q.pop();//删掉该飞机的编号和所占的廊桥位置 } x[k.top()]++;//无论这个是否能接到某些飞机的后面，它接的位置总是空缺的（因为它所在的廊桥编号可以i\u0026gt;n） q.push((nihao){p[i].second,k.top()});//推入它离开的时间和离开的位置 k.pop(); //删除该位置 } priority_queue\u0026lt;nihao\u0026gt; w; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt; \u0026gt; j; for(int i=1;i\u0026lt;=m2;i++)j.push(i); for(int i=1;i\u0026lt;=m2;i++) { while (!w.empty()\u0026amp;\u0026amp;w.top().a\u0026lt;=t[i].first) { j.push(w.top().b); w.pop(); } y[j.top()]++; w.push((nihao){t[i].second,j.top()}); j.pop(); } for(int i=1;i\u0026lt;=n;i++)x[i]+=x[i-1]; for(int i=1;i\u0026lt;=n;i++)y[i]+=y[i-1]; for(int i=0;i\u0026lt;=n;i++) ans=max(ans,x[i]+y[n-i]); printf(\u0026#34;%d\u0026#34;,ans); return 0; } ","date":"2024-09-07T21:27:48+08:00","permalink":"http://localhost:1313/p/p0009%E5%BB%8A%E6%A1%A5%E5%88%86%E9%85%8D/","title":"P0009廊桥分配"},{"content":"简述 给定一串全为 $1$ 的数列，再给定一个集合 $P$，经过三种操作使该数列变为 $p_i$ 的位置为 $1$ 其余的位置都为 $0$。\n三种操作中，每个操作的每个下标都有各自操作的代价，即要最小化操作代价和，即考虑 $dp$。\n思路 操作分为三种，\n操作 $a$ 将前缀 $v_i$ 全部变为 $0$。 操作 $b$ 将单个下标 $v_i$ 赋值为 $0$。 操作 $c$ 将单个下标 $v_i$ 赋值为 $1$。 可观察到，操作 $a$ 和 $b$ 有相似之处，倘如将 $b$ 操作执行 $i$ 遍其操作就等价于一个 $a_i$。易知前缀操作可以求出最小值，即 $a_i=min(a_i,\\sum b_i)$。\n进一步考虑，$a_i$ 和 $b_i$ 可以同时操作，即前缀操作最小值也要 $dp$，每一步新的 $a_i$ 可由两种操作而来。\n$a_i=a_{i-1}+b_i$，$a_i$ 可以由 $a_{i-1}$ 转移过来。 $a_i=min(a_i,\\sum b_i)$，直接比较两个前缀数组的大小。 即前缀操作最小值的方程即为 $a_i=min(min(a_i,\\sum b_i),a_{i-1}+b_i)$。\n之后考虑如何 $dp$。\n对于每个下标为 $p_i$ 时，保证该下标为 $1$，此刻也需要决策，不能直接 $dp_i=dp_ {i-1} $，因为满足此刻的条件还有其他两种操作可以满足，$dp_i=a_i+c_i$，$dp_i=a_{i-1}$。\n考虑到 $p_i$ 下标不一定为第一个所以可以开一个变量 $sum$ 专门存所有下标为 $p_i$ 的 $c_i$ 值。 即对于每个下标为 $p_i$ 时 $dp_i=min(dp_{i-1},a_i+sum,a_{i-1}+sum-c_i)$。\n对于下标不为 $p_i$ 时，$dp_i=min(dp_{i-1}+b_i,a_i+sum)$。\n此刻复杂度为 $O(qn)$，绝对假。\n显然我们发现对于数组 $b$ 完全不用一遍遍的加，可以直接使用前缀和数组 $b$，其次发现对于位置为非 $p_i$ 的位置其实不需要考虑，$dp$ 数组的继承可以直接由 $i-1$ 变为 $p_{i-1}$ 。\n而为什么这样子，观察下标不为 $p_i$ 的方程， $dp_i=min(dp_{i-1}+b_i,a_i+sum)$，将数组 $b$ 变为前缀数组， $dp$ 方程变为 $dp_i=min(dp_{i-1}+b_i-b_{i-1},a_i+sum)$。\n而对于 $a_i+sum$,这是对于每一步都需要进行的转移，直到下标为 $p_i$ 依然这样转移。\n其中有一步贪心,若在非 $p_i$ 位置中，存在一点 $i$ 使得 $a_i+sum\u0026lt;dp_{i-1}+b_i-b_{i-1}$，那么从该点之后到下一个 $p_i$ 之前总存在 $a_i+sum\\leq dp_{i-1}+b_i-b_{i-1}$。\n因为 $a_i+sum$ 的意思是把前缀全变为 $0$，再加上之前 $P_i$ 位置变为 $1$ 的代价。那么该点 $i$ 推出的 $dp$ 状态转移中 $dp_{i-1}+b_i-b_{i-1}$ 也等价于把前缀全变为 $0$，再加上之前 $P_i$ 位置变为 $1$ 的代价。 而前缀操作最小值已经预处理过了，所以贪心成立。\n所以可以直接将两个 $dp$ 方程合并成一个，枚举每一个 $p_i$ 即可。 此刻的数组 $b$ 为操作 $b$ 的前缀和数组。 $dp_{p_i}=min(dp_{p_{i-1}}+b_{p_{i}-1}-b_{p_{}i-1},a_{p_i}+sum,a_{p_i-1}+sum-c_{p_i})$。\n最后只需要特判一下 $p_m$ 是否恰好等于 $n$，再单独 $dp$ 一遍即可。\n由于 $dp$ 转移时初始状态为由 $dp_0$ 开始，所以不用更新数组。\n这样复杂度降为了 $O(\\sum m)$，即 $O(n)$。\n记得开 $long long $！！！\n源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long int a[610000],b[610000],c[610000],p[610000]; int dp[610000],s[610000]; #define re read() int read(){ int data = 0, w = 1; char ch = 0; while (!isdigit(ch) \u0026amp;\u0026amp; ch != \u0026#39;-\u0026#39;) ch = getchar(); if (ch == \u0026#39;-\u0026#39;) w = -1, ch = getchar(); while (isdigit(ch)) data = 10 * data + ch - \u0026#39;0\u0026#39;, ch = getchar(); return w * data; } void qwrite(int x,char ed=\u0026#39;\\n\u0026#39;) { if(!x) {putchar(\u0026#39;0\u0026#39;),putchar(ed);return;} char w[44];int cnt=0; if(x\u0026lt;0) putchar(\u0026#39;-\u0026#39;),x=-x; while(x) w[++cnt]=(x%10)+\u0026#39;0\u0026#39;,x/=10;++cnt; while(--cnt) putchar(w[cnt]);putchar(ed); } int n,q; int Min(int x,int y,int z) { x=min(x,y);x=min(x,z);return x; } void init() { for(int i=1;i\u0026lt;=n;i++)a[i]=re;for(int i=1;i\u0026lt;=n;i++)b[i]=re,b[i]+=b[i-1];for(int i=1;i\u0026lt;=n;i++)c[i]=re; for(int i=1;i\u0026lt;=n;i++)\ta[i]=Min(a[i],b[i],a[i-1]+b[i]-b[i-1]); } signed main() { n=re; init(); q=re; while(q--) { int m=re;int sum=0; for(int i=1;i\u0026lt;=m;i++) { p[i]=re;sum+=c[p[i]]; dp[p[i]]=Min(dp[p[i-1]]+b[p[i]-1]-b[p[i-1]],a[p[i]]+sum,a[p[i]-1]+sum-c[p[i]]); } if(p[m]==n){qwrite(dp[n]);continue;} dp[n]=min(dp[p[m]]+b[n]-b[p[m]],a[n]+sum); qwrite(dp[n]); } return 0; } ","date":"2024-09-06T21:21:46+08:00","permalink":"http://localhost:1313/p/p0002%E6%B6%88%E9%99%A4%E5%BA%8F%E5%88%97/","title":"P0002消除序列"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"http://localhost:1313/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu4699868770670889127.jpg","permalink":"http://localhost:1313/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"http://localhost:1313/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu6307248181568134095.jpg","permalink":"http://localhost:1313/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"http://localhost:1313/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu10664154974910995856.jpg","permalink":"http://localhost:1313/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","date":"2019-03-08T00:00:00Z","permalink":"http://localhost:1313/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"http://localhost:1313/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu5876398126655421130.jpg","permalink":"http://localhost:1313/p/emoji-support/","title":"Emoji Support"}]